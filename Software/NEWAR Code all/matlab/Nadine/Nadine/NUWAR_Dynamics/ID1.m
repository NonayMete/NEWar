%function [Q,lambda] = ID1(V,d1V,d2V,theta,d1theta,d2theta, alpha, beta);
%
%Inverse Dynamics Function 1
%
% This function solves the inverse dynamics problem for a specific point in
% time - for a given set of positions, velocities and accelerations of the
% dependent coordinates it calculates the required motor torques.
%
% This function is used by the 'IDTraj' function to calculate the motor
% torques at each time point.
%
% Input Parameters:
%      V = position of the travelling plate (in base coordinates, in metres)
%      d1V = velocity of the travelling plate
%      d2V = acceleration of the travelling plate
%      theta = control arm (motor) angles
%      d1theta = angular velocity of the control arm angles
%      d2theta = anglular acceleration of the control arm angles
%      alpha = the orientation of the motors in the 'alpha' direction, in degrees
%      beta  = the orientation of the motors in the 'beta' direction, in degrees
%
% Default values:
%      V, d1V, d2V, theta, d1theta, d2theta: are required
%      alpha and beta: alpha=beta=0, corresponding to Delta configuration
%
% Note: all input angles are in degrees.
%
% Output values:
%      Q = vector of motor torques
%      lambda = vector of Lagrange multipliers
%
% Author: Nadine Frame 1999

function [Q,lambda] = ID1(V,d1V,d2V,theta,d1theta,d2theta, alpha, beta);

%Set defaults:
if nargin < 6
   disp('Insufficient parameters.');
   help ID1;
   return
end
if nargin < 7 | isempty(alpha)
   alpha =0;    %default value corresponding to Delta configuration
end
if nargin < 8 | isempty(beta)
	beta=0;      %default value corresponding to Delta configuration
end 
	
%Initialise Parameters:
InitArms;
InitDynamics;

phi=[0;120;240];  %angles of the motor array

%Convert angles from degrees to radians
alpha=alpha*pi/180;
beta=beta*pi/180;
phi=phi*pi/180;
theta=theta*pi/180;
d1theta=d1theta*pi/180;
d2theta=d2theta*pi/180;

R=Ra-Rb;

%Assign vector components:
phi1=phi(1);
phi2=phi(2);
phi3=phi(3);
theta1=theta(1);
theta2=theta(2);
theta3=theta(3);
d1theta1=d1theta(1);
d1theta2=d1theta(2);
d1theta3=d1theta(3);
d2theta1=d2theta(1);
d2theta2=d2theta(2);
d2theta3=d2theta(3);
x=V(1);
y=V(2);
z=V(3);
d1x=d1V(1);
d1y=d1V(2);
d1z=d1V(3);
d2x=d2V(1);
d2y=d2V(2);
d2z=d2V(3);

%Inverse Dynamics Calculations:
%Partial derivatives of the constraint functions:
A11 = 1/2*(-4*R*cos(phi1)-La*(2*cos(beta-phi1-theta1)+2*cos(beta-phi1+theta1)+...
   sin(alpha+beta-phi1-theta1)-sin(alpha-beta+phi1-theta1)-sin(alpha+beta-phi1+theta1)+...
   sin(alpha-beta+phi1+theta1))+4*x);

A12 = 1/2*(-La*cos(alpha+beta-phi1-theta1)-La*cos(alpha-beta+phi1-theta1)+...
   La*cos(alpha+beta-phi1+theta1)+La*cos(alpha-beta+phi1+theta1)-4*R*sin(phi1)+...
   2*La*sin(beta-phi1-theta1)+2*La*sin(beta-phi1+theta1)+4*y);

A13 = 2*(La*cos(alpha)*sin(theta1)+z);

A21 = 1/2*(-4*R*cos(phi2)-La*(2*cos(beta-phi2-theta2)+2*cos(beta-phi2+theta2)+...
   sin(alpha+beta-phi2-theta2)-sin(alpha-beta+phi2-theta2)-sin(alpha+beta-phi2+theta2)+...
   sin(alpha-beta+phi2+theta2))+4*x);

A22 = 1/2*(-La*cos(alpha+beta-phi2-theta2)-La*cos(alpha-beta+phi2-theta2)+...
   La*cos(alpha+beta-phi2+theta2)+La*cos(alpha-beta+phi2+theta2)-4*R*sin(phi2)+...
   2*La*sin(beta-phi2-theta2)+2*La*sin(beta-phi2+theta2)+4*y);

A23 = 2*(La*cos(alpha)*sin(theta2)+z);

A31 = 1/2*(-4*R*cos(phi3)-La*(2*cos(beta-phi3-theta3)+2*cos(beta-phi3+theta3)+...
   sin(alpha+beta-phi3-theta3)-sin(alpha-beta+phi3-theta3)-sin(alpha+beta-phi3+theta3)+...
   sin(alpha-beta+phi3+theta3))+4*x);

A32 = 1/2*(-La*cos(alpha+beta-phi3-theta3)-La*cos(alpha-beta+phi3-theta3)+...
   La*cos(alpha+beta-phi3+theta3)+La*cos(alpha-beta+phi3+theta3)-4*R*sin(phi3)+...
   2*La*sin(beta-phi3-theta3)+2*La*sin(beta-phi3+theta3)+4*y);

A33 = 2*(La*cos(alpha)*sin(theta3)+z);

% 3x3 matrix of the partial derivatives of the constraint functions:
A = [A11, A21, A31; A12, A22, A32; A13, A23, A33];

% Left hand side of the Lagrange equations:
B1 = 1/24*(-4*La*Mb*(cos(beta-phi1)*cos(theta1)+sin(alpha)*sin(beta-phi1)*sin(theta1))*...
   d1theta1^2-4*La*Mb*(cos(beta-phi2)*cos(theta2)+sin(alpha)*sin(beta-phi2)*sin(theta2))*...
   d1theta2^2-2*La*Mb*cos(beta-phi3-theta3)*d1theta3^2-2*La*Mb*cos(beta-phi3+theta3)*...
   d1theta3^2-La*Mb*sin(alpha+beta-phi3-theta3)*d1theta3^2+La*Mb*sin(alpha-beta+phi3-theta3)*...
   d1theta3^2+La*Mb*sin(alpha+beta-phi3+theta3)*d1theta3^2-La*Mb*sin(alpha-beta+phi3+theta3)*...
   d1theta3^2+24*Mb*d2x+24*Mc*d2x-La*Mb*cos(alpha+beta-phi1-theta1)*d2theta1+...
   La*Mb*cos(alpha-beta+phi1-theta1)*d2theta1-La*Mb*cos(alpha+beta-phi1+theta1)*d2theta1+...
   La*Mb*cos(alpha-beta+phi1+theta1)*d2theta1+2*La*Mb*sin(beta-phi1-theta1)*d2theta1-...
   2*La*Mb*sin(beta-phi1+theta1)*d2theta1-La*Mb*cos(alpha+beta-phi2-theta2)*d2theta2+...
   La*Mb*cos(alpha-beta+phi2-theta2)*d2theta2-La*Mb*cos(alpha+beta-phi2+theta2)*d2theta2+...
   La*Mb*cos(alpha-beta+phi2+theta2)*d2theta2+2*La*Mb*sin(beta-phi2-theta2)*d2theta2-...
   2*La*Mb*sin(beta-phi2+theta2)*d2theta2+4*La*Mb*(cos(theta3)*sin(alpha)*sin(beta-theta3)-...
   cos(beta-phi3)*sin(theta3))*d2theta3);

B2 = 1/24*(4*La*Mb*(cos(theta1)*sin(beta-phi1)-cos(beta-phi1)*sin(alpha)*sin(theta1))*...
   d1theta1^2+4*La*Mb*(cos(theta2)*sin(beta-phi2)-cos(beta-phi2)*sin(alpha)*sin(theta2))*...
   d1theta2^2-La*Mb*cos(alpha+beta-phi3-theta3)*d1theta3^2-La*Mb*cos(alpha-beta+phi3-theta3)*...
   d1theta3^2+La*Mb*cos(alpha+beta-phi3+theta3)*d1theta3^2+La*Mb*cos(alpha-beta+phi3+theta3)*...
   d1theta3^2+2*La*Mb*sin(beta-phi3-theta3)*d1theta3^2+2*La*Mb*sin(beta-phi3+theta3)*...
   d1theta3^2+24*Mb*d2y+24*Mc*d2y+2*La*Mb*cos(beta-phi1-theta1)*d2theta1-...
   2*La*Mb*cos(beta-phi1+theta1)*d2theta1+La*Mb*sin(alpha+beta-phi1-theta1)*d2theta1+...
   La*Mb*sin(alpha-beta+phi1-theta1)*d2theta1+La*Mb*sin(alpha+beta-phi1+theta1)*d2theta1+...
   La*Mb*sin(alpha-beta+phi2+theta1)*d2theta1+2*La*Mb*cos(beta-phi2-theta2)*d2theta2-...
   2*La*Mb*cos(beta-phi2+theta2)*d2theta2+La*Mb*sin(alpha+beta-phi2-theta2)*d2theta2+...
   La*Mb*sin(alpha-beta+phi2-theta2)*d2theta2+La*Mb*sin(alpha+beta-phi2+theta2)*d2theta2+...
   La*Mb*sin(alpha-beta+phi2+theta2)*d2theta2+4*La*Mb*(cos(beta-phi3)*cos(theta3)*sin(alpha)+...
   sin(beta-phi3)*sin(theta3))*d2theta3);

B3 = 1/12*(18*g*Mb+12*g*Mc+2*La*Mb*cos(alpha)*sin(theta1)*d1theta1^2+2*La*Mb*cos(alpha)*...
   sin(theta2)*d1theta2^2-La*Mb*sin(alpha-theta3)*d1theta3^2+La*Mb*sin(alpha+theta3)*...
   d1theta3^2+12*Mb*d2z+12*Mc*d2z-La*Mb*cos(alpha-theta1)*d2theta1-La*Mb*cos(alpha+theta1)*...
   d2theta1-La*Mb*cos(alpha-theta2)*d2theta2-La*Mb*cos(alpha+theta2)*d2theta2-...
   2*La*Mb*cos(alpha)*cos(theta3)*d2theta3);

B = [B1;B2;B3];

% Calculation of Lagrange multipliers (lambda) by Gaussian elimination:
lambda=A\B;

%Left hand sides of the Lagrange equations:
D1=[(-2*(-12*d2theta1*Ja - 4*d2theta1*La^2*Mb - 12*d2theta1*La^2*Mj + ...
      6*g*H*La*Ma*cos(alpha - theta1) + d2z*La*Mb*cos(alpha - theta1) + ...
      3*g*La*Mb*cos(alpha - theta1) + 6*g*La*Mj*cos(alpha - theta1) + ...
      6*g*H*La*Ma*cos(alpha + theta1) + d2z*La*Mb*cos(alpha + theta1) + ...
      3*g*La*Mb*cos(alpha + theta1) + 6*g*La*Mj*cos(alpha + theta1)) + ...
      d2x*La*Mb*(-cos(alpha + beta - phi1 - theta1) + ...
      cos(alpha - beta + phi1 - theta1) - cos(alpha + beta - phi1 + theta1) + ...
      cos(alpha - beta + phi1 + theta1) + 2*sin(beta - phi1 - theta1) - ...
      2*sin(beta - phi1 + theta1)) + d2y*La*Mb*(2*cos(beta - phi1 - theta1) - ...
      2*cos(beta - phi1 + theta1) + sin(alpha + beta - phi1 - theta1) + ...
      sin(alpha - beta + phi1 - theta1) + sin(alpha + beta - phi1 + theta1) + ...
      sin(alpha - beta + phi1 + theta1)))/24];

D2 = [(-2*(-12*d2theta2*Ja - 4*d2theta2*La^2*Mb - 12*d2theta2*La^2*Mj + ...
      6*g*H*La*Ma*cos(alpha - theta2) + d2z*La*Mb*cos(alpha - theta2) + ...
      3*g*La*Mb*cos(alpha - theta2) + 6*g*La*Mj*cos(alpha - theta2) + ...
      6*g*H*La*Ma*cos(alpha + theta2) + d2z*La*Mb*cos(alpha + theta2) + ...
      3*g*La*Mb*cos(alpha + theta2) + 6*g*La*Mj*cos(alpha + theta2)) + ...
      d2x*La*Mb*(-cos(alpha + beta - phi2 - theta2) + ...
      cos(alpha - beta + phi2 - theta2) - cos(alpha + beta - phi2 + theta2) + ...
      cos(alpha - beta + phi2 + theta2) + 2*sin(beta - phi2 - theta2) - ...
      2*sin(beta - phi2 + theta2)) + d2y*La*Mb*(2*cos(beta - phi2 - theta2) - ...
      2*cos(beta - phi2 + theta2) + sin(alpha + beta - phi2 - theta2) + ...
      sin(alpha - beta + phi2 - theta2) + sin(alpha + beta - phi2 + theta2) + ...
      sin(alpha - beta + phi2 + theta2)))/24];

D3 = [(-2*(-12*d2theta3*Ja - 4*d2theta3*La^2*Mb - 12*d2theta3*La^2*Mj + ...
      6*g*H*La*Ma*cos(alpha - theta3) + d2z*La*Mb*cos(alpha - theta3) + ...
      3*g*La*Mb*cos(alpha - theta3) + 6*g*La*Mj*cos(alpha - theta3) + ...
      6*g*H*La*Ma*cos(alpha + theta3) + d2z*La*Mb*cos(alpha + theta3) + ...
      3*g*La*Mb*cos(alpha + theta3) + 6*g*La*Mj*cos(alpha + theta3)) + ...
      d2x*La*Mb*(-cos(alpha + beta - phi3 - theta3) + ...
      cos(alpha - beta + phi3 - theta3) - ...
      cos(alpha + beta - phi3 + theta3) + cos(alpha - beta + phi3 + theta3) + ...
      2*sin(beta - phi3 - theta3) - 2*sin(beta - phi3 + theta3)) + ...
      d2y*La*Mb*(2*cos(beta - phi3 - theta3) - 2*cos(beta - phi3 + theta3) + ...
      sin(alpha + beta - phi3 - theta3) + sin(alpha - beta + phi3 - theta3) + ...
      sin(alpha + beta - phi3 + theta3) + sin(alpha - beta + phi3 + theta3)))/24];

D = [D1;D2;D3];

% Partial derivatives of the constraint functions:
A14 = -2*La*(-R*cos(theta1)*sin(alpha)*sin(beta)+R*cos(beta)*sin(theta1)+...
   (cos(theta1)*sin(alpha)*sin(beta-phi1)-cos(beta-phi1)*sin(theta1))*x+...
   (cos(beta-phi1)*cos(theta1)*sin(alpha)+sin(beta-phi1)*sin(theta1))*y-...
   cos(alpha)*cos(theta1)*z);
A25 = -2*La*(-R*cos(theta2)*sin(alpha)*sin(beta)+R*cos(beta)*sin(theta2)+...
   (cos(theta2)*sin(alpha)*sin(beta-phi2)-cos(beta-phi2)*sin(theta2))*x+...
   (cos(beta-phi2)*cos(theta2)*sin(alpha)+sin(beta-phi2)*sin(theta2))*y-...
   cos(alpha)*cos(theta2)*z);
A36 = -2*La*(-R*cos(theta3)*sin(alpha)*sin(beta)+R*cos(beta)*sin(theta3)+...
   (cos(theta3)*sin(alpha)*sin(beta-phi3)-cos(beta-phi3)*sin(theta3))*x+...
   (cos(beta-phi3)*cos(theta3)*sin(alpha)+sin(beta-phi3)*sin(theta3))*y-...
   cos(alpha)*cos(theta3)*z);

E = [A14,0,0;0,A25,0;0,0,A36];

% Calculation of the vector of motor torques:
Q = D - E*lambda;
