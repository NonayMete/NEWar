% function [timef]=ConstraintViolation(timepos,timetheta, alpha, beta, Ra, Rb, La, Lb);
%
% eg [timef]=ConstraintViolation(timepos,timetheta,0,0)
%
% This function checks the violation of the constraint conditions for a trajectory. 
% It is used to check the error in trajectories generated by the Forward Dynamics
% function.
% This function returns the values of the three constraint functions (f1,f2,f3) for 
% each time point in the trajectory.
%
% Input Parameters:
%
%      timepos = time history of the travelling plate position
%      timetheta = time history of the motor angles
%      (Note: timepos and timetheta are both in the standard form of the output from 
%      the Traj1999 and FDTraj functions)
%      alpha = the orientation of the motors in the 'alpha' direction, in degrees
%      beta  = the orientation of the motors in the 'beta' direction, in degrees
%      Ra = distance from the centre of the base to the motors
%      Rb = distance from the centre of the travelling plate to the point of connection
%           between the travelling plate and forearm
%      La = length of the control arm
%      Lb = length of the forearm
%
% Default values:
%      timepos and timetheta: are required
%      alpha and beta: alpha=beta=0, corresponding to Delta configuration
%      Ra, Rb, La, Lb: assigned by InitArms
%
% Author: Nadine Frame 1999


function [timef]=ConstraintViolation(timepos,timetheta, alpha, beta, Ra, Rb, La, Lb);

%Set defaults
if nargin == 0	%make sure that parameters have been supplied
   disp('Parameters are required:')
   help ConstraintViolation;
   return
end
if nargin < 2
   disp('Insufficient Parameters')
   help Constraint Violation;
   return
if nargin <= 2,	%set the default values for alpha and beta - DELTA configuration
	%alpha = -35.26;
   %beta  = 60;
   alpha = 0;
   beta  = 0;
end 
if nargin <= 4,	%initialise geometric parameters
   InitArms;
end

phi=[0;120;240];  %angles of the motor array

%convert angles in degrees to radians
timetheta=timetheta*pi/180;
phi=phi*pi/180;
alpha=alpha*pi/180;
beta=beta*pi/180;

R=Ra-Rb;

%set time points:
timef(:,1)=timepos(:,1);

numpoints=size(timepos,1);

for i = 1:numpoints
   V(1:3)=timepos(i,2:4);
   theta(1:3)=timetheta(i,2:4);
   
   %constraint functions:
   f1 = -Lb^2+(La*sin(phi(1))*(cos(theta(1))*sin(beta)-cos(beta)*sin(alpha)*sin(theta(1)))+...
      cos(phi(1))*(R+La*cos(beta)*cos(theta(1))+La*sin(alpha)*sin(beta)*sin(theta(1)))-...
      V(1))^2+(cos(phi(1))*(-La*cos(theta(1))*sin(beta)+La*cos(beta)*sin(alpha)*sin(theta(1)))+...
      sin(phi(1))*(R+La*cos(beta)*cos(theta(1))+La*sin(alpha)*sin(beta)*sin(theta(1)))-...
      V(2))^2+(La*cos(alpha)*sin(theta(1))+V(3))^2;
   
   f2 = -Lb^2+(La*sin(phi(2))*(cos(theta(2))*sin(beta)-cos(beta)*sin(alpha)*sin(theta(2)))+...
      cos(phi(2))*(R+La*cos(beta)*cos(theta(2))+La*sin(alpha)*sin(beta)*sin(theta(2)))-...
      V(1))^2+(cos(phi(2))*(-La*cos(theta(2))*sin(beta)+La*cos(beta)*sin(alpha)*sin(theta(2)))+...
      sin(phi(2))*(R+La*cos(beta)*cos(theta(2))+La*sin(alpha)*sin(beta)*sin(theta(2)))-...
      V(2))^2+(La*cos(alpha)*sin(theta(2))+V(3))^2;
   
   f3 = -Lb^2+(La*sin(phi(3))*(cos(theta(3))*sin(beta)-cos(beta)*sin(alpha)*sin(theta(3)))+...
      cos(phi(3))*(R+La*cos(beta)*cos(theta(3))+La*sin(alpha)*sin(beta)*sin(theta(3)))-...
      V(1))^2+(cos(phi(3))*(-La*cos(theta(3))*sin(beta)+La*cos(beta)*sin(alpha)*sin(theta(3)))+...
      sin(phi(3))*(R+La*cos(beta)*cos(theta(3))+La*sin(alpha)*sin(beta)*sin(theta(3)))-...
      V(2))^2+(La*cos(alpha)*sin(theta(3))+V(3))^2;
   
   %vector of constraint functions:
   timef(i,2:4)=[f1,f2,f3];
end;
